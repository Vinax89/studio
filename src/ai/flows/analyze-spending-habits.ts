
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Analyzes user's spending habits based on uploaded financial documents.
 *
 * - analyzeSpendingHabits - A function that analyzes spending habits.
 * - AnalyzeSpendingHabitsInput - The input type for the analyzeSpendingHabits function.
 * - AnalyzeSpendingHabitsOutput - The return type for the analyzeSpendingHabits function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const DATA_URI_REGEX = /^data:[\w.+-]+\/[\w.+-]+;base64,[A-Za-z0-9+/=]+$/;
const MAX_DATA_URI_SIZE = 5 * 1024 * 1024; // 5MB

const GoalSchema = z.object({
    id: z.string(),
    name: z.string(),
    targetAmount: z.number(),
    currentAmount: z.number(),
    deadline: z.string(),
    importance: z.number().describe("User's importance rating for this goal, from 1 (not important) to 5 (very important)."),
});

const AnalyzeSpendingHabitsInputSchema = z.object({
  financialDocuments: z
    .array(
      z
        .string()
        .regex(DATA_URI_REGEX, {
          message:
            "Invalid data URI format. Expected 'data:<mimetype>;base64,<encoded_data>'.",
        })
        .refine(
          value => {
            const base64 = value.split(',')[1];
            if (!base64) return false;
            return Buffer.from(base64, 'base64').length <= MAX_DATA_URI_SIZE;
          },
          {
            message: `Encoded data must be <= ${MAX_DATA_URI_SIZE} bytes`,
          }
        )
    )
    .describe(
      'An array of financial documents as data URIs that must include a MIME type and use Base64 encoding. Expected format: data:<mimetype>;base64,<encoded_data>.'
    ),
  userDescription: z.string().describe('A description of the user and their general financial situation.'),
  goals: z.array(GoalSchema).describe("An array of the user's financial goals, including their self-rated importance."),
});
export type AnalyzeSpendingHabitsInput = z.infer<typeof AnalyzeSpendingHabitsInputSchema>;

const AnalyzeSpendingHabitsOutputSchema = z.object({
  spendingAnalysis: z.string().describe('An analysis of the user spending habits.'),
  savingsOpportunities: z.string().describe('Identified potential savings opportunities.'),
  recommendations: z.string().describe('Personalized financial recommendations, taking goal importance into account.'),
});
export type AnalyzeSpendingHabitsOutput = z.infer<typeof AnalyzeSpendingHabitsOutputSchema>;

export async function analyzeSpendingHabits(input: AnalyzeSpendingHabitsInput): Promise<AnalyzeSpendingHabitsOutput> {
  return analyzeSpendingHabitsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'analyzeSpendingHabitsPrompt',
  input: {schema: AnalyzeSpendingHabitsInputSchema},
  output: {schema: AnalyzeSpendingHabitsOutputSchema},
  prompt: `You are a personal finance advisor for nursing professionals. Analyze the user's spending habits based on the provided financial documents, their personal description, and their stated financial goals.

Crucially, you must consider the 'importance' ranking of each goal. Recommendations should prioritize achieving the goals the user has marked as most important.

User Description: {{{userDescription}}}

User's Financial Goals (with importance out of 5):
{{#each goals}}
- Goal: {{name}}
  Target: \${{targetAmount}}
  Current: \${{currentAmount}}
  Deadline: {{deadline}}
  Importance: {{importance}}/5
{{/each}}

Financial Documents:
{{#each financialDocuments}}
  Document: {{media url=this}}
{{/each}}

Based on all this information, provide:
1.  **spendingAnalysis**: A summary of spending patterns found in the documents.
2.  **savingsOpportunities**: Areas where the user could potentially save money.
3.  **recommendations**: Personalized, actionable recommendations that help the user achieve their *most important* goals faster.`,
});

const analyzeSpendingHabitsFlow = ai.defineFlow(
  {
    name: 'analyzeSpendingHabitsFlow',
    inputSchema: AnalyzeSpendingHabitsInputSchema,
    outputSchema: AnalyzeSpendingHabitsOutputSchema,
  },
  async input => {
    const parsed = AnalyzeSpendingHabitsInputSchema.safeParse(input);
    if (!parsed.success) {
      throw new Error(parsed.error.issues.map(i => i.message).join(', '));
    }
    const {output} = await prompt(parsed.data);
    if (!output) {
      throw new Error('No output returned from analyzeSpendingHabitsPrompt');
    }
    return output;
  }
);
